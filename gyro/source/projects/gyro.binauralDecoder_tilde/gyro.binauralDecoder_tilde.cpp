/// @file
///    @ingroup     minexamples
///    @copyright    Copyright 2018 The Min-DevKit Authors. All rights reserved.
///    @license    Use of this source code is governed by the MIT License found in the License.md file.

///Copyright Sofia Checa 2020.

//binaurally render a soundfield, using HRTFs

#include "c74_min.h"
#include "ambisonics/ambisonic_binaural_decoder.h"
#include "audio_buffer_conversion.h"

#include "dsp/sh_hrir_creator.h"
#include "utils/wav.h"
#include <string>

// these are already included in the above, but just in case
#include "dsp/fft_manager.h"
#include "dsp/partitioned_fft_filter.h"
#include "third_party/pffft/pffft.h"

using namespace c74::min; //TODO do we actually need std for strings?
//using namespace vraudio; //TODO clean these (after everything else compiles)

std::ifstream filenameToIstream(const string s){
    std::ifstream ifs;
    ifs.open(s, std::ifstream::in);  //TODO need safety checking that the file opened! And must throw / catch exception in the constructor!
    if(ifs.good()){
        return ifs;
    } else {
        error("Unable to open file" + s);
        exit(3);
    }
}

//given a certain ambisonic order, use the sadie assets to generate an AudioBuffer containing the appropriate HRIRs.
unique_ptr<vraudio::AudioBuffer> asset2HRIR(const int k, const float sr){
    std::string s(std::string("WAV/Subject_002/SH/sh_hrir_order_") + std::to_string(k) + std::string(".wav"));
    vraudio::Resampler resampler;
    return vraudio::CreateShHrirsFromAssets(s, sr, &resampler);
}

//given a certain ambisonic order, use the sadie ambi-encoded wave files to generate an AudioBuffer containing the appropriate HRIRs.
unique_ptr<vraudio::AudioBuffer> wav2HRIR(const int k, const float sr){
    path p(std::string("sh_hrir_order_") + std::to_string(k) + std::string(".wav")); //The path function lets us tap into the file preferences of Max. See c74_min_path.h
    std::ifstream ifs((filenameToIstream(string(p))));
    unique_ptr<const vraudio::Wav> wav(vraudio::Wav::CreateOrNull(&ifs));
    vraudio::Resampler resampler;
    return vraudio::CreateShHrirsFromWav(*wav, sr, &resampler);
}

class binauralDecoder : public object<binauralDecoder>, public vector_operator<> {
private:
    //everything will be initialised in the member initialisation lists in the constructor
    const int kAmbisonicOrder;
    const int kNumIns;
    const unique_ptr<vraudio::AudioBuffer> sh_hrirs; //stands for Spherical Harmonic encoded Head-Related Impulse Response
    vraudio::FftManager fftManager;
    vraudio::AmbisonicBinauralDecoder binaural_decoder;

    std::vector< std::unique_ptr<inlet<>> >    m_inlets; //note that this must be called m_inputs!
public:
    MIN_DESCRIPTION    { "Decodes a soundfield to binaural. Use argument to select ambisonic order. Ambisonic order 1 by default." };
    MIN_TAGS           { "gyro, binaural, ambisonics, audio" };
    MIN_AUTHOR         { "Cycling '74" };
    MIN_RELATED        { "index~, buffer~, wave~" };
    
    /// constructor that allows for number of outlets to be defined by the ambisonic order argument.
    binauralDecoder(const atoms& args = {})
      : kAmbisonicOrder(args.empty() ? 1: int(args[0])),    //set the default ambisonic order to 1 if there are no arguments
        kNumIns((kAmbisonicOrder+1)*(kAmbisonicOrder+1)),   //TODO turn this into a function. see hoa_rotator.cc for GetNumNthOrder
    
        //note that there are two ways to create spherical harmonic encoded hrirs. You can create them from wav or asset files. Both of those are generated by an external Matlab script.
//        sh_hrirs(wav2HRIR(kAmbisonicOrder, samplerate())), //samplerate is a member of base vector_operator class
        sh_hrirs(asset2HRIR(kAmbisonicOrder, samplerate())),
    
        fftManager(vector_size()), //vector_size is a member of base vector_operator class
        binaural_decoder(*sh_hrirs, vector_size(), &fftManager)
        {
        cout << "inside constructor" << kAmbisonicOrder << endl;
        
        //inlet handling
        //most max objects do not complain about extra arguments, so I don't either.
        if(!args.empty() && (int(args[0]) > 3 || int(args[0]) < 1)){
            error("This package currently supports only 1st, 2nd, and 3rd order ambisonics.");
        }
        for (auto i=0; i < kNumIns; ++i) {
            //TODO the channel number should be in the assist message. String nonsense.
            m_inlets.push_back( std::make_unique<inlet<>>(this, "(signal) Channel", "signal") );
        }
    }
    
    outlet<>  out1    { this, "(signal) Stereo Left", "signal" };
    outlet<>  out2    { this, "(signal) Stereo Right", "signal" };
    
    void operator()(audio_bundle input, audio_bundle output) {

        auto nFrames = input.frame_count();
        vraudio::AudioBuffer r_inputAudioBuffer(kNumIns, nFrames);      // resonance-style audio buffer for input
        vraudio::AudioBuffer r_outputAudioBuffer(2, nFrames);           // resonance-style audio buffer for output
        Min2Res(input, &r_inputAudioBuffer);                            // transfer audio data from min-style audio_bundle to resonance-style audioBuffer

//        StereoFromSoundfield(r_inputAudioBuffer, &r_outputAudioBuffer); //convert the soundfield into stereo using mid-side
        binaural_decoder.Process(r_inputAudioBuffer, &r_outputAudioBuffer); //decode the buffer!

        Res2Min(r_outputAudioBuffer, &output);                    // transfer audio data from resonance-style audioBuffer to min-style audio_bundle

    }
};


MIN_EXTERNAL(binauralDecoder);
