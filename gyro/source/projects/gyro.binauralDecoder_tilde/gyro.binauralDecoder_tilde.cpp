/// @file
///    @ingroup     minexamples
///    @copyright    Copyright 2018 The Min-DevKit Authors. All rights reserved.
///    @license    Use of this source code is governed by the MIT License found in the License.md file.

///Copyright Sofia Checa 2020.

//binaurally render a soundfield, using HRTFs

#include "c74_min.h"
#include "ambisonics/ambisonic_binaural_decoder.h"
#include "audio_buffer_conversion.h"

#include "dsp/sh_hrir_creator.h"
#include "utils/wav.h"
#include <string>
#include <sstream>
#include <iomanip>

using namespace c74::min;
//note that the vraudio namespace is used for Resonance objects. I do not "use" this namespace so that is clear to the viewer where these objects come from

//std::ifstream filenameToIstream(const std::string s){
//    std::ifstream ifs;
//    ifs.open(s, std::ifstream::in);  //TODO need safety checking that the file opened! And must throw / catch exception in the constructor!
//    if(ifs.good()){
//        return ifs;
//    } else {
//        error("Unable to open file" + s);
//        exit(3);
//    }
//}

//given a certain ambisonic order, use the sadie assets to generate an AudioBuffer containing the appropriate HRIRs.
unique_ptr<vraudio::AudioBuffer> asset2SHHRIR(const int subject, const int order, const float sr){
    std::ostringstream convert;   // stream used for the conversion with appropriate zero padding
    convert << std::setw(3) << std::setfill('0') << subject;
    std::string subjectString = convert.str();
    
    std::string s("WAV/Subject_" + subjectString + "/SH/sh_hrir_order_" + std::to_string(order) + ".wav");
    vraudio::Resampler resampler;
    return vraudio::CreateShHrirsFromAssets(s, sr, &resampler);
}

//given a certain ambisonic order, use the sadie ambi-encoded wave files to generate an AudioBuffer containing the appropriate HRIRs.
//unique_ptr<vraudio::AudioBuffer> wav2HRIR(const int k, const float sr){
//    path p(std::string("sh_hrir_order_") + std::to_string(k) + std::string(".wav")); //The path function lets us tap into the file preferences of Max. See c74_min_path.h
//    std::ifstream ifs((filenameToIstream(std::string(p))));
//    unique_ptr<const vraudio::Wav> wav(vraudio::Wav::CreateOrNull(&ifs));
//    vraudio::Resampler resampler;
//    return vraudio::CreateShHrirsFromWav(*wav, sr, &resampler);
//}

class binauralDecoder : public object<binauralDecoder>, public vector_operator<> {
private:
    //everything will be initialised in the member initialisation lists in the constructor
    const int kAmbisonicOrder;
    const int kNumIns;
    const unique_ptr<vraudio::AudioBuffer> sh_hrirs; //stands for Spherical Harmonic encoded Head-Related Impulse Response
    vraudio::FftManager fftManager;
    vraudio::AmbisonicBinauralDecoder binaural_decoder;

    std::vector< std::unique_ptr<inlet<>> >    m_inlets; //note that this must be called m_inputs!
public:
    MIN_DESCRIPTION    { "Decodes a soundfield to binaural. Use argument to select ambisonic order. Ambisonic order 1 by default." };
    MIN_TAGS           { "gyro, binaural, ambisonics, audio" };
    MIN_AUTHOR         { "Cycling '74" };
    MIN_RELATED        { "index~, buffer~, wave~" };
    
    /// constructor that allows for number of outlets to be defined by the ambisonic order argument.
    binauralDecoder(const atoms& args = {})
      : kAmbisonicOrder(args.empty() ? 1: int(args[0])),    //set the default ambisonic order to 1 if there are no arguments
        kNumIns((kAmbisonicOrder+1)*(kAmbisonicOrder+1)),   //TODO turn this into a function. see hoa_rotator.cc for GetNumNthOrder
    
        //note that there are two ways to create spherical harmonic encoded hrirs. You can create them from wav or asset files. Both of those are generated by an external Matlab script.
//        sh_hrirs(wav2HRIR(kAmbisonicOrder, samplerate())), //samplerate is a member of base vector_operator class. Will be reset if/when dsp chain is compiled
        sh_hrirs(asset2SHHRIR(2, kAmbisonicOrder, samplerate())),
    
        fftManager(vector_size()), //vector_size is a member of base vector_operator class. Will be reset if/when dsp chain is compiled
        binaural_decoder(*sh_hrirs, vector_size(), &fftManager)
    {
        
        //inlet handling
        //most max objects do not complain about extra arguments, so I don't either.
        if(!args.empty() && (int(args[0]) > 3 || int(args[0]) < 1)){
            error("This package currently supports only 1st, 2nd, and 3rd order ambisonics.");
        }
        std::string inletHelpMessage("(signal) Channel ");
        for (auto i=0; i < kNumIns; ++i) {
            m_inlets.push_back( std::make_unique<inlet<>>(this, inletHelpMessage + std::to_string(i+1), "signal") ); //human labelling for channels is 1-indexed
        }
    }
    //TODO: why is this outside the constructor
    outlet<>  out1    { this, "(signal) Stereo Left", "signal" };
    outlet<>  out2    { this, "(signal) Stereo Right", "signal" };
    
    
    
    attribute<int, threadsafe::no, limit::clamp> subjectID_attr {this, "HRIR Subject", 2,
        description{"Select an HRIR Subject to be used for the binaural decoding. Subject IDs range from 1 to 20."},
        range{1,3}
    };
    
    message<> setSubject {this, "subject", "set the SADIE-I HRTF Database Subject to be used for the binaural decoding.",
        MIN_FUNCTION{
            subjectID_attr = args[0];
            return{};
        }
    };
    
    void operator()(audio_bundle input, audio_bundle output) {

        auto nFrames = input.frame_count();
        vraudio::AudioBuffer r_inputAudioBuffer(kNumIns, nFrames);      // resonance-style audio buffer for input
        vraudio::AudioBuffer r_outputAudioBuffer(2, nFrames);           // resonance-style audio buffer for output
        Min2Res(input, &r_inputAudioBuffer);                            // transfer audio data from min-style audio_bundle to resonance-style audioBuffer

        binaural_decoder.Process(r_inputAudioBuffer, &r_outputAudioBuffer);     //decode the buffer!

        Res2Min(r_outputAudioBuffer, &output);                          // transfer audio data from resonance-style audioBuffer to min-style audio_bundle

    }
};


MIN_EXTERNAL(binauralDecoder);
